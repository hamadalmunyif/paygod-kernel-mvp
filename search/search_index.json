{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to PayGod Kernel MVP","text":"<p>This is the main page of the documentation for the PayGod Kernel MVP project.</p> <p>To learn more about the project, please visit the GitHub repository.</p>"},{"location":"#about-the-project","title":"About the project","text":"<p>PayGod Kernel is a lightweight, extensible, and secure kernel for building payment applications.</p> <p>This documentation is divided into two main sections:</p> <ul> <li>User Guide: For users who want to use the PayGod Kernel.</li> <li>Developer Guide: For developers who want to contribute to the project.</li> </ul>"},{"location":"00_VISION/","title":"Vision","text":"<p>Paygod Kernel provides contracts + evidence ledger + metrics model for continuous compliance.</p>"},{"location":"01_KERNEL_AXIOMS/","title":"Paygod Kernel Axioms","text":"<p>This document defines the fundamental, non-negotiable truths (Axioms) that govern the design and operation of the Paygod Kernel. These are not merely guidelines; they are architectural constraints that must be upheld to ensure the system's integrity, security, and compliance.</p> <p>Each axiom is structured to provide clarity on its definition, rationale, enforcement, and tradeoffs.</p>"},{"location":"01_KERNEL_AXIOMS/#axiom-1-schema-is-law","title":"Axiom 1: Schema Is Law","text":""},{"location":"01_KERNEL_AXIOMS/#1-what","title":"1. What","text":"<p>The JSON Schema definitions are the absolute and final authority on data validity. No code shall implement validation logic that contradicts or extends the schema without the schema itself being updated first.</p>"},{"location":"01_KERNEL_AXIOMS/#2-why","title":"2. Why","text":"<p>To prevent \"Shadow Validation\" where the actual rules of the system diverge from the documented contract. This ensures that validation is consistent across all environments (Local, CI, Production) and languages.</p>"},{"location":"01_KERNEL_AXIOMS/#3-counterexample","title":"3. Counterexample","text":"<p>A developer adds a check <code>if ($obj.amount &gt; 1000)</code> in a PowerShell script but leaves the schema's <code>maximum</code> value as <code>undefined</code>. A third-party integrator validates against the schema, sends <code>2000</code>, and fails mysteriously in production. The contract was lied to.</p>"},{"location":"01_KERNEL_AXIOMS/#4-enforcement","title":"4. Enforcement","text":"<ul> <li>CI Gate: All PRs must pass <code>paygod-cli validate --schema</code> which strictly enforces the schema.</li> <li>Library: The <code>Paygod.SchemaValidator</code> library is the only approved validation mechanism in the kernel code.</li> <li>Policy: <code>SCHEMA_SEMVER_POLICY.md</code> mandates strict format assertions.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#5-tradeoffs","title":"5. Tradeoffs","text":"<ul> <li>Rigidity: Changing a rule requires a schema change and potentially a version bump, which is slower than \"hot-patching\" a script.</li> <li>Learning Curve: Developers must learn JSON Schema vocabulary instead of writing ad-hoc <code>if</code> statements.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#6-non-goals","title":"6. Non-goals","text":"<ul> <li>Does not replace business logic validation that requires external state (e.g., \"User has sufficient balance\"). Schema validates the shape and intrinsic correctness of the message, not its contextual validity.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#7-references","title":"7. References","text":"<ul> <li>SCHEMA_SEMVER_POLICY.md</li> <li>JSON Schema Validation Spec (Draft 2020-12)</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#axiom-2-ledger-immutability","title":"Axiom 2: Ledger Immutability","text":""},{"location":"01_KERNEL_AXIOMS/#1-what_1","title":"1. What","text":"<p>Once a decision or assessment is recorded in the Ledger, it can never be modified or deleted. Corrections are made only by appending new \"Correction\" records that reference the original.</p>"},{"location":"01_KERNEL_AXIOMS/#2-why_1","title":"2. Why","text":"<p>To guarantee a tamper-evident audit trail that satisfies strict financial and regulatory compliance requirements (OSCAL, SOC2). Trust is built on the assurance that history cannot be rewritten.</p>"},{"location":"01_KERNEL_AXIOMS/#3-counterexample_1","title":"3. Counterexample","text":"<p>An admin notices a typo in a risk assessment and runs a SQL <code>UPDATE</code> to fix it. The audit trail is broken; auditors can no longer verify what the state was at the time of the original decision, potentially hiding fraud or incompetence.</p>"},{"location":"01_KERNEL_AXIOMS/#4-enforcement_1","title":"4. Enforcement","text":"<ul> <li>Cryptographic Chaining: Each ledger entry contains a hash of the previous entry.</li> <li>WORM Storage: Underlying storage media (e.g., S3 Object Lock, Append-only DB) is configured to Write-Once-Read-Many.</li> <li>API Constraints: The Kernel API exposes no <code>PUT</code> or <code>DELETE</code> endpoints for ledger resources.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#5-tradeoffs_1","title":"5. Tradeoffs","text":"<ul> <li>Storage Growth: The database grows indefinitely.</li> <li>Complexity: \"Reading\" the current state requires replaying the history or maintaining a separate \"State View\" (CQRS pattern).</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#6-non-goals_1","title":"6. Non-goals","text":"<ul> <li>Does not apply to ephemeral data like user session caches or draft assessments that haven't been finalized.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#7-references_1","title":"7. References","text":"<ul> <li>NIST SP 800-53 (AU-9 Protection of Audit Information)</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#axiom-3-zero-trust-execution","title":"Axiom 3: Zero-Trust Execution","text":""},{"location":"01_KERNEL_AXIOMS/#1-what_2","title":"1. What","text":"<p>The Kernel assumes that no caller, internal or external, is implicitly trusted. Every request must carry verifiable cryptographic proof of identity and authorization (e.g., a signed token).</p>"},{"location":"01_KERNEL_AXIOMS/#2-why_2","title":"2. Why","text":"<p>Perimeter defense is insufficient for modern cloud-native architectures. If an attacker breaches the outer firewall, they should not have free reign over the internal microservices.</p>"},{"location":"01_KERNEL_AXIOMS/#3-counterexample_2","title":"3. Counterexample","text":"<p>The <code>DecisionService</code> trusts any request coming from <code>localhost</code> or the internal subnet. An attacker gains shell access to a web server in the same subnet and can now issue fraudulent decisions without authentication.</p>"},{"location":"01_KERNEL_AXIOMS/#4-enforcement_2","title":"4. Enforcement","text":"<ul> <li>mTLS: Mutual TLS is required for all service-to-service communication.</li> <li>Token Validation: Every endpoint validates the JWT signature, expiration, and scopes before processing.</li> <li>Identity Propagation: User identity is propagated through the call chain; services do not act as \"God Mode\" superusers.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#5-tradeoffs_2","title":"5. Tradeoffs","text":"<ul> <li>Latency: Additional overhead for cryptographic handshakes and token validation on every hop.</li> <li>Management: Requires robust PKI and Key Management infrastructure.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#6-non-goals_2","title":"6. Non-goals","text":"<ul> <li>Does not imply that we don't use firewalls. Network segmentation is still a valid defense-in-depth layer, just not the only one.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#7-references_2","title":"7. References","text":"<ul> <li>NIST SP 800-207 (Zero Trust Architecture)</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#axiom-4-evidence-based-decisions","title":"Axiom 4: Evidence-Based Decisions","text":""},{"location":"01_KERNEL_AXIOMS/#1-what_3","title":"1. What","text":"<p>Every decision output by the DAA/Paygod system must be traceable back to specific input evidence (data points, user answers, external API responses). A decision cannot exist in a vacuum.</p>"},{"location":"01_KERNEL_AXIOMS/#2-why_3","title":"2. Why","text":"<p>To explain why a decision was made (Explainable AI / XAI) and to allow for auditing the quality of decisions. \"Because the AI said so\" is not an acceptable justification in financial compliance.</p>"},{"location":"01_KERNEL_AXIOMS/#3-counterexample_3","title":"3. Counterexample","text":"<p>A loan application is rejected. The system logs \"Rejected\" but doesn't link it to the specific credit bureau report or the specific policy rule that triggered the rejection. Debugging or appealing the decision is impossible.</p>"},{"location":"01_KERNEL_AXIOMS/#4-enforcement_3","title":"4. Enforcement","text":"<ul> <li>Data Model: The <code>DecisionRecord</code> schema requires an <code>evidence</code> array containing references (IDs/Hashes) to all inputs used.</li> <li>Provenance: Input data is stored with metadata about its source and timestamp.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#5-tradeoffs_3","title":"5. Tradeoffs","text":"<ul> <li>Data Volume: Storing full evidence chains increases storage requirements.</li> <li>Privacy: Evidence may contain PII, requiring strict access controls and potentially redaction strategies for long-term storage.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#6-non-goals_3","title":"6. Non-goals","text":"<ul> <li>Does not require storing a full snapshot of the entire world state, only the specific inputs that influenced the calculation.</li> </ul>"},{"location":"01_KERNEL_AXIOMS/#7-references_3","title":"7. References","text":"<ul> <li>EU AI Act (Transparency and Record-Keeping)</li> </ul>"},{"location":"02_ARCHITECTURE/","title":"Paygod Kernel Architecture","text":""},{"location":"02_ARCHITECTURE/#1-context-problem-statement","title":"1. Context &amp; Problem Statement","text":"<p>Paygod Kernel is the high-assurance execution engine designed to bridge the gap between Decision Intelligence (provided by DAA) and Financial Compliance/Execution.</p> <p>In modern fintech and regulatory environments, \"deciding\" what to do and \"executing\" that decision compliantly are distinct challenges. Existing systems often couple these tightly, leading to \"Spaghetti Code\" where business logic, compliance checks, and execution scripts are inextricably mixed. This makes audits difficult and changes risky.</p> <p>Paygod Kernel solves this by: 1. Decoupling the Decision (Policy/Logic) from the Execution (Mechanism). 2. Enforcing a strict, immutable Ledger of all actions. 3. Treating Compliance as code (OSCAL) rather than manual checklists.</p>"},{"location":"02_ARCHITECTURE/#2-goals-non-goals","title":"2. Goals &amp; Non-Goals","text":""},{"location":"02_ARCHITECTURE/#goals","title":"Goals","text":"<ul> <li>Auditability: Every state change is cryptographically verifiable.</li> <li>Modularity: New Decision Packs (DAA) can be plugged in without recompiling the Kernel.</li> <li>Resilience: The system fails safely and recovers automatically.</li> <li>Strictness: Invalid data is rejected at the boundary; no \"garbage in, garbage out\".</li> <li>Extensibility: Support both Community (local) and Enterprise (SaaS) deployments via the same core.</li> </ul>"},{"location":"02_ARCHITECTURE/#non-goals","title":"Non-Goals","text":"<ul> <li>General Purpose CMS: This is not a generic content management system.</li> <li>Real-time Trading: While fast, the Kernel prioritizes consistency and correctness over microsecond-level latency required for HFT.</li> </ul>"},{"location":"02_ARCHITECTURE/#3-system-decomposition","title":"3. System Decomposition","text":"<p>The architecture follows a Microservices pattern centered around a shared immutable Ledger, designed for the Open Core model.</p>"},{"location":"02_ARCHITECTURE/#31-core-services-open-kernel","title":"3.1 Core Services (Open Kernel)","text":"<ol> <li>Ingress Gateway (API):</li> <li>Authenticates requests (mTLS/JWT).</li> <li>Validates input schemas (Strict Mode).</li> <li> <p>Routes to appropriate internal services.</p> </li> <li> <p>Decision Runtime (DAA Host):</p> </li> <li>Loads and executes Decision Packs.</li> <li>Stateless execution engine.</li> <li> <p>Inputs: <code>Context</code> + <code>Pack</code>. Outputs: <code>Decision</code> + <code>Evidence</code>.</p> </li> <li> <p>Ledger Service:</p> </li> <li>The \"Write-Only\" heart of the system.</li> <li>Appends cryptographically chained records.</li> <li> <p>Provides \"Time Travel\" queries (State at Time T).</p> </li> <li> <p>Executor Service:</p> </li> <li>Listens to Ledger events (e.g., <code>DecisionFinalized</code>).</li> <li>Performs side effects (e.g., Send Money, Update KYC Status).</li> <li>Idempotent design.</li> </ol>"},{"location":"02_ARCHITECTURE/#32-extension-points-interfaces","title":"3.2 Extension Points (Interfaces)","text":"<p>To support the Open Core model (ADR-0006), the Kernel exposes interfaces that can be swapped at runtime:</p> Interface Community Implementation (Default) Enterprise Implementation (Proprietary) <code>ILedgerStore</code> LocalFileSystem: Appends to <code>ledger.jsonl</code> on disk. S3/BlobStore: Appends to immutable object storage with WORM locking. <code>IPolicySource</code> LocalDirectory: Loads YAML packs from <code>/packs</code> folder. GitOps/DB: Loads packs from managed Git repo or Policy Registry. <code>IAuthProvider</code> StaticToken: Simple API Key or Local User. OIDC/SAML: Integration with Okta, Azure AD, Keycloak. <code>IAuditSink</code> Console/File: Logs to STDOUT or file. Splunk/Datadog: Forwards structured logs to SIEM. <code>IPanicSwitch</code> LocalFileFlag: Checks a local lock file. GlobalRedisKey: Checks a distributed Redis key for instant cluster-wide freeze."},{"location":"02_ARCHITECTURE/#33-boundaries","title":"3.3 Boundaries","text":"<ul> <li>Public Boundary: The Ingress Gateway is the only component exposed to the internet/public network.</li> <li>Trust Boundary: Services inside the mesh trust each other's identity (via mTLS) but strictly validate each other's data payloads.</li> </ul>"},{"location":"02_ARCHITECTURE/#4-deployment-modes","title":"4. Deployment Modes","text":""},{"location":"02_ARCHITECTURE/#mode-a-standalone-community-default","title":"Mode A: Standalone (Community Default)","text":"<p>Optimized for developer experience and local testing. - Single Process: All services run within one binary or a minimal <code>docker-compose</code>. - Zero Dependencies: Uses SQLite and local files. No external DB or Cache required. - Goal: <code>docker run paygod/kernel</code> just works in &lt; 5 seconds.</p>"},{"location":"02_ARCHITECTURE/#mode-b-distributed-enterprise-scale","title":"Mode B: Distributed (Enterprise Scale)","text":"<p>Optimized for high availability and compliance. - Microservices: Services deployed as separate K8s pods. - External State: Uses Postgres/RDS, Redis, and S3. - Goal: 99.99% SLA, Zero-Trust security mesh.</p>"},{"location":"02_ARCHITECTURE/#5-key-flows","title":"5. Key Flows","text":""},{"location":"02_ARCHITECTURE/#the-observation-measurement-impact-evidence-ledger-loop","title":"The \"Observation \u2192 Measurement \u2192 Impact \u2192 Evidence \u2192 Ledger\" Loop","text":"<ol> <li>Observation: The system ingests raw data (e.g., User Form, Credit Report).</li> <li>Measurement: DAA Packs quantify this data against criteria (e.g., Risk Score = 85/100).</li> <li>Impact: The system determines the consequence (e.g., \"High Risk\" -&gt; \"Manual Review Required\").</li> <li>Evidence: All inputs and intermediate scores are bundled as a verifiable evidence package.</li> <li>Ledger: The final Decision Record (with Evidence hash) is sealed in the Ledger.</li> </ol>"},{"location":"02_ARCHITECTURE/#6-trust-boundaries-security-model","title":"6. Trust Boundaries &amp; Security Model","text":""},{"location":"02_ARCHITECTURE/#61-zero-trust-assumptions","title":"6.1 Zero-Trust Assumptions","text":"<ul> <li>The internal network is considered hostile.</li> <li>No service trusts another based on IP address.</li> <li>All secrets (DB connection strings, API keys) are injected at runtime via Vault/Secrets Manager, never stored in code.</li> </ul>"},{"location":"02_ARCHITECTURE/#62-pii-data-privacy","title":"6.2 PII &amp; Data Privacy","text":"<ul> <li>PII Zone: User profile data is stored in a segregated <code>IdentityService</code>.</li> <li>Anonymization: The Ledger stores references (UUIDs) to users, not PII itself, wherever possible.</li> <li>Secrets: Strictly forbidden in the Ledger.</li> </ul>"},{"location":"02_ARCHITECTURE/#7-operational-model","title":"7. Operational Model","text":""},{"location":"02_ARCHITECTURE/#71-slos-service-level-objectives","title":"7.1 SLOs (Service Level Objectives)","text":"<ul> <li>Availability: 99.9% (allows ~43m downtime/month).</li> <li>Latency: 95% of Decision requests &lt; 500ms.</li> <li>Durability: 99.9999999% (11 9s) for Ledger data.</li> </ul>"},{"location":"02_ARCHITECTURE/#72-failure-modes","title":"7.2 Failure Modes","text":"<ul> <li>Ledger Down: System enters \"Read-Only\" mode. No new decisions can be finalized.</li> <li>DAA Service Down: Requests queue up or fail fast (depending on priority).</li> <li>Validation Failure: Request rejected immediately with 400 Bad Request (protects system integrity).</li> </ul>"},{"location":"02_ARCHITECTURE/#73-kill-switch-panic-mode","title":"7.3 Kill-Switch (Panic Mode)","text":"<ul> <li>Function: Instantly freezes all Executor side-effects (e.g., stop money movement) while allowing Read/Decision operations.</li> <li>Implementation: Defined via <code>IPanicSwitch</code> interface.<ul> <li>Community: Toggled via a local file or CLI command.</li> <li>Enterprise: Toggled via API/UI, propagated globally via Redis/Consul.</li> </ul> </li> </ul>"},{"location":"02_ARCHITECTURE/#8-decision-links-adrs","title":"8. Decision Links (ADRs)","text":"<ul> <li>ADR-001: Use JSON Schema for Contracts</li> <li>ADR-002: Immutable Ledger Strategy</li> <li>ADR-003: .NET for Kernel / Python for Data Science</li> <li>ADR-005: Unified CLI Validator</li> <li>ADR-006: Repository Separation Strategy</li> </ul>"},{"location":"03_GOVERNANCE_MODEL/","title":"Governance","text":"<p>Pack lifecycle: Draft\u2192Reviewed\u2192Approved\u2192Published\u2192Activated\u2192Retired. Trust levels: community/verified/certified.</p>"},{"location":"04_LEDGER_MODEL/","title":"Ledger","text":"<p>Append-only, tamper-evident. Hash chain and verification.</p>"},{"location":"05_METRICS_MODEL/","title":"Metrics","text":"<p>MetricSpec defines unit/boundary/method/uncertainty. Measurement executes. Impact computes delta + attribution.</p>"},{"location":"06_DATA_CONSTITUTION/","title":"Data Constitution","text":"<p>Enforceable rules for data schema, metadata, access, provenance.</p>"},{"location":"07_AGENTIC_SECURITY_PROFILE/","title":"Agentic Security Profile","text":"<p>Tool allowlist, autonomy bounds, checkpoints, audit trails.</p>"},{"location":"08_PRIVACY_ADMT_PROFILE/","title":"Privacy + ADMT Profile","text":"<p>Structured explanations, review hooks, minimization, retention.</p>"},{"location":"09_CROSS_BORDER_DATA_PROFILE/","title":"Cross-border Data Profile","text":"<p>Residency constraints, transfer approvals, logging, key locality.</p>"},{"location":"10_RELEASE_SAFETY/","title":"Release Safety","text":"<p>Progressive delivery, rollback triggers, kill-switch, postmortems.</p>"},{"location":"11_OUTPUT_ARTIFACTS/","title":"Output Artifacts (Plan / Findings / Truth Ledger)","text":"<p>Paygod Kernel supports a deterministic compliance loop:</p> <ol> <li>Plan: what will be evaluated (inputs, pinned packs, digests)</li> <li>Findings: signals for triage (flags), references-only evidence pointers</li> <li>Truth Ledger: append-only proof log of final decisions (allow/deny/error)</li> </ol> <p>See <code>contracts/schemas/*</code> for the canonical JSON Schemas.</p>"},{"location":"12_STANDARD_CONTROL_PACKS/","title":"Standard Control Packs (ISO pattern)","text":"<p>A Standard Control Pack maps a policy pack to an external standard (e.g. ISO).</p>"},{"location":"12_STANDARD_CONTROL_PACKS/#why","title":"Why","text":"<ul> <li>Makes compliance executable (controls-as-code)</li> <li>Produces reproducible proof outputs (plan/findings/truth ledger)</li> <li>Enables community contribution per control</li> </ul>"},{"location":"12_STANDARD_CONTROL_PACKS/#required-fields","title":"Required fields","text":"<p>In <code>spec.standard</code>: - <code>name</code> (e.g. ISO/IEC 27001:2022) - <code>controls[]</code> (id, title, intent)</p>"},{"location":"12_STANDARD_CONTROL_PACKS/#example","title":"Example","text":"<p>See: <code>packs/core/iso27001-policy-review</code></p>"},{"location":"BELLOOP_ARTIFACT_PROTOCOL/","title":"Belloop Artifact Protocol (BAP)","text":""},{"location":"BELLOOP_ARTIFACT_PROTOCOL/#scope-mvp","title":"Scope (MVP)","text":"<p>BAP defines the stable, schema-validated artifacts that power Belloop. In MVP, only three artifact kinds are mandatory: - decision - evidence - ledger_entry</p> <p>Other artifacts (findings_report, impact, plan_report, measurement, metricspec, observation) are out-of-scope for MVP unless explicitly enabled.</p>"},{"location":"BELLOOP_ARTIFACT_PROTOCOL/#source-of-truth","title":"Source of Truth","text":"<p>The system is governed by validated artifacts (schemas), not by code or services. Any producer (CLI/service/pack) is interchangeable if it emits compliant artifacts.</p>"},{"location":"BELLOOP_ARTIFACT_PROTOCOL/#envelope-required","title":"Envelope (Required)","text":"<p>Every artifact MUST be wrapped in a common envelope defined by the canonical schema:</p> <p>Fields (defined by contract): - correlation_id - data - kind - producer - schema - schema_id - schema_ref - schema_version - timestamp</p> <p>Required fields (must exist): - data - kind - producer - schema_version - timestamp</p> <p>Notes: - correlation_id is OPTIONAL in MVP by the current envelope contract (recommended when available).</p> <p>No envelope =&gt; non-compliant output.</p>"},{"location":"BELLOOP_ARTIFACT_PROTOCOL/#references-only-security-rule","title":"References-only (Security Rule)","text":"<p>Artifacts MUST NOT store raw sensitive content or PII. - evidence MUST contain references/hashes/ids only. - ledger_entry MUST be append-only, hash-chained, and references-only.</p> <p>Raw payloads belong to external storage and must be referenced by hash/uri/id.</p>"},{"location":"BELLOOP_ARTIFACT_PROTOCOL/#schema-stability","title":"Schema Stability","text":"<ul> <li>Existing schemas are never broken.</li> <li>Breaking changes require a new schema version.</li> <li>Changes require test vectors and ADRs when architectural.</li> </ul>"},{"location":"BELLOOP_ARTIFACT_PROTOCOL/#pack-compliance","title":"Pack Compliance","text":"<p>Every Pack MUST declare: - inputs consumed - artifact kinds produced - supported schema versions - validation/tests for outputs</p>"},{"location":"BELLOOP_ARTIFACT_PROTOCOL/#implemented-files","title":"Implemented files","text":"<ul> <li>contracts/schemas/belloop_artifact_envelope.schema.json</li> <li>docs/BELLOOP_ARTIFACT_PROTOCOL.md</li> </ul>"},{"location":"DAA_INTEGRATION_PROFILE/","title":"DAA Integration Profile: Decoupled Decision Intelligence","text":""},{"location":"DAA_INTEGRATION_PROFILE/#1-overview","title":"1. Overview","text":"<p>This profile defines the integration strategy between Paygod Kernel (the Execution Engine) and Decision Assessment Assistant (DAA) (the Intelligence Engine).</p> <p>Strategic Principle: The two systems are strictly decoupled. DAA acts as an untrusted external advisor (\"Oracle\"), while Paygod Kernel retains absolute sovereignty over execution and compliance.</p>"},{"location":"DAA_INTEGRATION_PROFILE/#2-integration-pattern-the-advisor-judge-model","title":"2. Integration Pattern: The \"Advisor-Judge\" Model","text":"<p>We employ an asynchronous, message-based integration pattern where DAA provides recommendations, but Paygod Kernel makes decisions.</p> Feature DAA (The Advisor) Paygod Kernel (The Judge) Role Analyze data, calculate scores, suggest actions. Validate inputs, enforce policy, execute transactions. Nature Probabilistic (AI/ML), fast-changing. Deterministic (Rule-based), stable. Output <code>Assessment</code> (Opinion) <code>Decision</code> (Law) Failure Mode Hallucination, Timeout. Rejection, Safe Fallback."},{"location":"DAA_INTEGRATION_PROFILE/#3-communication-protocol","title":"3. Communication Protocol","text":""},{"location":"DAA_INTEGRATION_PROFILE/#31-data-flow","title":"3.1 Data Flow","text":"<ol> <li>Request: Paygod sends an anonymized <code>ObservationContext</code> to DAA.</li> <li>Analysis: DAA runs the appropriate Pack (e.g., Credit Risk Pack).</li> <li>Response: DAA returns a signed <code>AssessmentResult</code>.</li> <li>Validation: Paygod validates the signature and schema of the result.</li> <li>Judgment: Paygod compares the result against <code>Guardrails</code> (Policy).</li> <li>Execution: If passed, Paygod creates a <code>DecisionRecord</code> and executes.</li> </ol>"},{"location":"DAA_INTEGRATION_PROFILE/#32-the-air-gap-logic","title":"3.2 The \"Air Gap\" Logic","text":"<p>To prevent AI risks from contaminating the financial core: - No Direct DB Access: DAA never touches the Paygod Ledger directly. - No Side Effects: DAA cannot call external APIs (e.g., Stripe) directly. It can only return a JSON saying \"I recommend paying X\". - Strict Schema: DAA's output must match the <code>Measurement</code> schema exactly. Any extra fields or hallucinations are stripped/rejected.</p>"},{"location":"DAA_INTEGRATION_PROFILE/#4-guardrails-safety","title":"4. Guardrails &amp; Safety","text":"<p>Paygod Kernel implements a Defense-in-Depth layer specifically for DAA integration:</p>"},{"location":"DAA_INTEGRATION_PROFILE/#41-schema-sanitization","title":"4.1 Schema Sanitization","text":"<p>The Kernel's Ingress Gateway strips any unrecognized fields from DAA responses. If DAA hallucinates a field <code>\"confidence_level\": \"very high\"</code>, it is discarded unless defined in the strict schema.</p>"},{"location":"DAA_INTEGRATION_PROFILE/#42-threshold-policies","title":"4.2 Threshold Policies","text":"<p>Paygod defines \"Hard Limits\" that override DAA: - Example: \"If DAA recommends a loan &gt; $50,000, force Manual Review regardless of the AI score.\"</p>"},{"location":"DAA_INTEGRATION_PROFILE/#43-circuit-breakers","title":"4.3 Circuit Breakers","text":"<p>If DAA error rates or latency spike, Paygod automatically switches to a \"Fallback Strategy\" (e.g., Rule-based logic or Manual Queue) to maintain business continuity.</p>"},{"location":"DAA_INTEGRATION_PROFILE/#5-deployment-lifecycle","title":"5. Deployment Lifecycle","text":"<p>Because the systems are decoupled, they have independent lifecycles:</p> <ul> <li>DAA Packs: Can be updated daily (e.g., new fraud patterns). Deployed to DAA Runtime.</li> <li>Paygod Kernel: Updated quarterly (e.g., regulatory changes). Deployed to Secure Enclave.</li> </ul>"},{"location":"DAA_INTEGRATION_PROFILE/#6-compliance-mapping","title":"6. Compliance Mapping","text":"<p>This profile satisfies OSCAL controls for external system reliance: - SA-9 (External System Services): Defines trust boundaries. - SI-10 (Information Input Validation): Strict schema enforcement on DAA outputs.</p>"},{"location":"DAA_INTEGRATION_PROFILE/#7-references","title":"7. References","text":"<ul> <li>Axiom 3: Zero-Trust Execution</li> <li>ADR 0004: Hybrid Tech Stack</li> </ul>"},{"location":"HANDOVER/","title":"Paygod Kernel MVP - Phase 1 Closed Handover","text":""},{"location":"HANDOVER/#direction-lock-non-negotiable","title":"Direction Lock (Non-Negotiable)","text":"<ul> <li>Phase 1: CLOSED at baseline commit 1b6be2e</li> <li>Baseline branch: main only</li> <li>Canonical Truth:</li> <li>contracts/ = Law</li> <li>docs/ = Literal reflection of contracts (no opinion)</li> <li>CI = Execution gate / enforcement</li> <li>No re-interpretation of Phase 1 decisions is allowed.</li> </ul>"},{"location":"HANDOVER/#repository-snapshot-as-generated","title":"Repository Snapshot (as generated)","text":"<ul> <li>Repository (origin): https://github.com/hamadalmunyif/paygod-kernel-mvp.git</li> <li>Branch: main</li> <li>Current HEAD: 1064dd2</li> <li>Generated At (UTC): 2026-02-05T16:27:53Z</li> </ul>"},{"location":"HANDOVER/#what-is-locked","title":"What is Locked","text":"<ul> <li>Contracts-first baseline at 1b6be2e</li> <li>BAP + Envelope contract alignment</li> <li>Schema governance (hash source-of-truth = Git HEAD blobs)</li> <li>CI as the enforcement mechanism</li> </ul>"},{"location":"HANDOVER/#what-is-not-implemented-yet-explicitly-out-of-phase-1","title":"What is NOT Implemented Yet (Explicitly Out of Phase 1)","text":"<ul> <li>Persistent services</li> <li>External APIs</li> <li>Runtime ledger infrastructure</li> <li>Multi-pack composition engine</li> </ul>"},{"location":"HANDOVER/#phase-2-entrypoint-single-goal","title":"Phase 2 Entrypoint (Single Goal)","text":"<p>Ship one deterministic Proof Run using: - packs/core/bap-output-validator-guard</p> <p>Outputs must be verifiable and enforced by CI: - decision - evidence (refs-only; no raw payload; no PII) - ledger_entry (hash-chained)</p>"},{"location":"HANDOVER/#phase-2-composition-rule-law-only-no-implementation-yet","title":"Phase 2 Composition Rule (Law-only, no implementation yet)","text":"<p>Phase 2 early execution uses single-pack authority. Multi-pack composition deferred. Future default: deny-wins + reason aggregation.</p>"},{"location":"LEDGER_RUNTIME_PROFILE/","title":"Runtime Ledger Profile (Phase 2)","text":""},{"location":"LEDGER_RUNTIME_PROFILE/#purpose","title":"Purpose","text":"<p>Provide an append-only runtime ledger trail outside git. This is NOT the repo proof ledger. Repo outputs remain deterministic and reproducible.</p> <p>Runtime ledger is meant to support: - audit trail per run - traceability to a git commit (HEAD) - refs-only integrity (hashes) without storing sensitive content</p>"},{"location":"LEDGER_RUNTIME_PROFILE/#enablement","title":"Enablement","text":"<p>Set the environment variable:</p> <ul> <li>PAYGOD_LEDGER_PATH = path to a JSONL file (will be created if missing)</li> </ul> <p>When PAYGOD_LEDGER_PATH is set, running: - tools/run_proof.ps1</p> <p>will append one JSON line (JSONL) per run by calling: - tools/append_ledger.ps1</p> <p>When PAYGOD_LEDGER_PATH is NOT set: - runtime ledger is disabled (no side effects outside git)</p>"},{"location":"LEDGER_RUNTIME_PROFILE/#format-jsonl","title":"Format (JSONL)","text":"<p>One line per entry (UTF-8, no BOM). Minimal refs-only record.</p> <p>Example (single JSON line): {\"v\":1,\"at_utc\":\"2026-02-05T22:58:13Z\",\"repo\":\"https://github.com//.git\",\"head\":\"\",\"decision\":{\"path\":\"docs/examples/proof_run/outputs/decision.json\",\"sha256\":\"\"},\"evidence\":{\"path\":\"docs/examples/proof_run/outputs/evidence.json\",\"sha256\":\"\"},\"ledger_entry\":{\"path\":\"docs/examples/proof_run/outputs/ledger_entry.json\",\"sha256\":\"\"}} <p>Fields: - v: record version (integer) - at_utc: runtime timestamp (UTC) \u2014 allowed because this file is outside git - repo: remote origin URL (informational) - head: git commit SHA (traceability) - decision/evidence/ledger_entry: refs-only paths + SHA256 digests</p>"},{"location":"LEDGER_RUNTIME_PROFILE/#policy-hard-rules","title":"Policy (Hard Rules)","text":"<ul> <li>refs-only: never store raw payloads, secrets, or full evidence content</li> <li>no PII: never write personal data into runtime ledger</li> <li>runtime ledger MUST be outside git (not committed)</li> </ul>"},{"location":"LEDGER_RUNTIME_PROFILE/#notes-on-time","title":"Notes on Time","text":"<p>Repo proof outputs must remain deterministic and reproducible. Runtime ledger time (at_utc) is permitted because it is: - outside git - not part of proof hashing within the repo</p>"},{"location":"LEDGER_RUNTIME_PROFILE/#operational-example","title":"Operational Example","text":"<p>Windows PowerShell:</p>"},{"location":"LEDGER_RUNTIME_PROFILE/#disable-default","title":"disable (default)","text":"<p>Remove-Item Env:\\PAYGOD_LEDGER_PATH -ErrorAction SilentlyContinue pwsh -File tools/run_proof.ps1</p>"},{"location":"LEDGER_RUNTIME_PROFILE/#enable","title":"enable","text":"<p>= \"C:\\Users\\User\\Desktop\\paygod_runtime_ledger.jsonl\" pwsh -File tools/run_proof.ps1 Get-Content  -Tail 1</p>"},{"location":"MVP_BACKLOG_GITHUB_ISSUES/","title":"MVP Backlog (GitHub Issues/Milestones)","text":"<p>This document provides a copy-paste backlog aligned with the MVP agreements: - CLI is the source of truth for pack run/test. - Ledger is append-only, immutable, strictly non-PII. - Evidence is references only (hashes + pointers), no raw sensitive payloads. - Packs are split into <code>packs/core</code> (cloud-agnostic) and <code>packs/providers/&lt;cloud&gt;</code> (provider-specific). - Security is gated on PR via GitHub Actions.</p>"},{"location":"MVP_BACKLOG_GITHUB_ISSUES/#milestones","title":"Milestones","text":"<ul> <li>M0: Repo hygiene + tooling baseline</li> <li>M1: Contracts enforcement (schema validation)</li> <li>M2: Multi-findings + truth decision outputs</li> <li>M3: File-based Ledger/Evidence stores + minimal services</li> <li>M4: Docker Compose MVP</li> <li>M5: Security gate + release discipline</li> <li>M6: Tests (xUnit) + regression</li> </ul>"},{"location":"MVP_BACKLOG_GITHUB_ISSUES/#pr-plan-a","title":"PR plan (a)","text":"<p>1) PR1 \u2014 Structure only (move-only)    - packs restructuring (<code>core/providers/_drafts</code>)    - provider lint script + CI step    - remove nested workflows    - pin SDK + build hygiene    - README CLI-only</p> <p>2) PR2 \u2014 Engine outputs (behavior)    - multi-findings + deterministic truth decision    - schema validation for packs/tests    - output artifacts always schema-valid (even on error)</p> <p>3) PR3 \u2014 MVP services    - validate/run APIs    - file-based ledger/evidence stores with chaining + verify    - docker compose volumes + healthchecks</p>"},{"location":"MVP_BACKLOG_GITHUB_ISSUES/#build-hygiene-b","title":"Build hygiene (b)","text":"<ul> <li><code>global.json</code> to pin .NET SDK</li> <li><code>Directory.Build.props</code> to enforce nullable + analyzers + warnings-as-errors</li> <li>Optional CI step: <code>dotnet format --verify-no-changes</code></li> </ul>"},{"location":"MVP_BACKLOG_GITHUB_ISSUES/#provider-separation-enforcement","title":"Provider separation enforcement","text":"<ul> <li>Lint script: <code>tools/ci/lint_core_packs_providers.py</code></li> <li>Config: <code>tools/ci/provider_lint_config.json</code></li> <li>Allowlist: <code>.paygod-provider-lint-allowlist</code></li> </ul>"},{"location":"MVP_BACKLOG_GITHUB_ISSUES/#minimal-tests-standard-core-packs","title":"Minimal tests standard (core packs)","text":"<p>A core pack must ship <code>tests/cases.yaml</code> that contains: - at least one allow case - at least one deny case - deny must be triggered by a concrete input difference (not an unrelated sample)</p> <p>If a pack is a skeleton or has no stable rules yet, it must live in <code>packs/_drafts/</code>.</p>"},{"location":"OPEN_CORE_POLICY/","title":"Open Core Policy","text":"<p>This document defines the strategic boundary between the Community Edition (Open Source) and Enterprise Edition (Commercial) of Paygod.</p>"},{"location":"OPEN_CORE_POLICY/#philosophy","title":"\ud83c\udfaf Philosophy","text":"<p>We believe in a \"Value-Based\" Open Core model. - Developers should have everything they need to run, test, and validate policies locally or in CI/CD for free. - Enterprises pay for centralized management, advanced integrations, governance at scale, and support.</p> <p>The \"Kernel\" is not a crippled version; it is the fully functional engine. The \"Enterprise\" edition is a wrapper that adds organizational capabilities.</p>"},{"location":"OPEN_CORE_POLICY/#the-boundary-open-vs-commercial","title":"\u2696\ufe0f The Boundary: Open vs. Commercial","text":"Component Category Open Source (Community) Commercial (Enterprise) Core Engine Full Kernel: Policy evaluation logic, ledger primitives, canonicalization, and validation engine. Same Kernel: The commercial product wraps the exact same binary/library. CLI Tooling Full CLI: <code>paygod validate</code>, <code>paygod test</code>, local execution. Enterprise CLI: Adds commands like <code>paygod login</code>, <code>paygod sync</code>, <code>paygod audit-upload</code>. Policy Packs Standard Packs: General purpose security &amp; compliance (e.g., CVEs, Admin Drift, Secrets). Premium Packs: Industry-specific standards (PCI-DSS, HIPAA, FedRAMP) and complex vendor integrations. Connectors Generic/Local: JSON file inputs, standard input streams (STDIN), basic webhooks. Native Integrations: AWS Org Sync, Azure AD, Okta, Jira, ServiceNow, Splunk forwarders. Data &amp; Storage Local/Ephemeral: Local file system, ephemeral in-memory validation. Persistent/SaaS: Long-term ledger storage, historical trending, team-based access control (RBAC). User Interface None: CLI and text-based outputs only. Management Dashboard: Web UI for visualization, reporting, user management, and audit trails."},{"location":"OPEN_CORE_POLICY/#protection-mechanisms","title":"\ud83d\udee1\ufe0f Protection Mechanisms","text":"<p>To ensure the commercial value is protected while maintaining a healthy open source ecosystem:</p> <ol> <li>License Separation:<ul> <li>Kernel: Apache 2.0 (Permissive).</li> <li>Enterprise Modules: Proprietary Commercial License.</li> </ul> </li> <li>Repository Isolation:<ul> <li>Proprietary code resides in a separate, private repository.</li> <li>It imports the Kernel as a dependency, ensuring no \"leakage\" of commercial IP into the public codebase.</li> </ul> </li> <li>Trademark Enforcement:<ul> <li>The name \"Paygod\" and the Logo are trademarks.</li> <li>Forks cannot use the official branding to sell a competing hosted service.</li> </ul> </li> </ol>"},{"location":"OPEN_CORE_POLICY/#contribution-guidelines","title":"\ud83e\udd1d Contribution Guidelines","text":"<ul> <li>Contributions to the Kernel are welcome and remain open source forever.</li> <li>We do not accept \"Enterprise-only\" features into the Kernel repo (e.g., code that strictly relies on a closed-source backend).</li> <li>All checks and balances (hashing, signatures) in the Kernel are transparent to guarantee trust.</li> </ul>"},{"location":"PUBLIC_API_POLICY/","title":"Public API Policy","text":"<p>This document defines the Public Surface Area of the Paygod Kernel. These are the contracts we guarantee to be stable according to Semantic Versioning (SemVer).</p>"},{"location":"PUBLIC_API_POLICY/#scope-of-stability","title":"\ud83c\udfaf Scope of Stability","text":"<p>The \"Public API\" consists of:</p>"},{"location":"PUBLIC_API_POLICY/#1-canonical-formats-strict","title":"1. Canonical Formats (Strict)","text":"<p>To ensure identical behavior across languages (Rust/Go/.NET), we mandate:</p> <ul> <li>Canonical JSON: MUST adhere to RFC 8785 (JCS).<ul> <li>Keys MUST be sorted lexicographically.</li> <li>Whitespace MUST be removed (compact).</li> <li>Numbers MUST be formatted as per IEEE 754 (e.g., <code>1e+2</code> becomes <code>100</code>).</li> </ul> </li> <li>Encoding: UTF-8 without BOM.</li> <li>Hashing:<ul> <li>Algorithm: SHA-256.</li> <li>Input: The UTF-8 bytes of the Canonical JSON string.</li> <li>Output Format: Hexadecimal (lowercase), e.g., <code>sha256:e3b0c442...</code> (prefix optional in internal storage, mandatory in public references).</li> </ul> </li> </ul>"},{"location":"PUBLIC_API_POLICY/#2-cli-contract","title":"2. CLI Contract","text":"<p>The <code>paygod</code> binary guarantees the following interface:</p> <ul> <li>Exit Codes:<ul> <li><code>0</code>: Success (Valid/Pass).</li> <li><code>1</code>: Validation Failure (Deny/Error).</li> <li><code>2</code>: System/Internal Error.</li> </ul> </li> <li>Output Format:<ul> <li>When <code>--json</code> is passed, the output MUST be a valid JSON object adhering to the <code>CliResponse</code> schema:     <code>json     {       \"status\": \"success|failure|error\",       \"code\": 0,       \"data\": { ... },       \"errors\": [ { \"message\": \"...\" } ]     }</code></li> </ul> </li> </ul>"},{"location":"PUBLIC_API_POLICY/#3-interfaces-srccoreinterfaces","title":"3. Interfaces (<code>src/Core/Interfaces/</code>)","text":"<ul> <li><code>ILedgerStore</code>: Contract for appending and reading ledger records.</li> <li><code>IPolicySource</code>: Contract for loading and resolving policy packs.</li> <li><code>IAuthProvider</code>: Contract for identity resolution.</li> <li><code>IAuditSink</code>: Contract for emitting audit events.</li> </ul>"},{"location":"PUBLIC_API_POLICY/#4-schemas-contractsschemas","title":"4. Schemas (<code>contracts/schemas/</code>)","text":"<ul> <li>All JSON Schemas in this directory are versioned.</li> <li>Breaking changes to schemas require a Major version bump.</li> </ul>"},{"location":"PUBLIC_API_POLICY/#excluded-internal-api","title":"\ud83d\udeab Excluded (Internal API)","text":"<p>Everything else is considered internal and may change at any time without a major version bump: *   Internal helper classes and utility functions. *   Database schema of the local SQLite store (implementation detail). *   In-memory data structures not exposed via interfaces.</p>"},{"location":"PUBLIC_API_POLICY/#versioning-rules-semver","title":"\ud83d\udd04 Versioning Rules (SemVer)","text":"<p>We follow Semantic Versioning 2.0.0:</p> <ul> <li>Major (X.y.z): Breaking changes to any Public API listed above.</li> <li>Minor (x.Y.z): New features (e.g., new interface method with default implementation, new CLI flag) that are backward compatible.</li> <li>Patch (x.y.Z): Bug fixes that do not change the Public API signature.</li> </ul>"},{"location":"PUBLIC_API_POLICY/#breaking-change-policy","title":"\u26a0\ufe0f Breaking Change Policy","text":"<p>If we must break a Public API: 1.  Deprecation Notice: We will mark the feature as <code>@deprecated</code> in a Minor release. 2.  Migration Guide: We will provide a document explaining how to upgrade. 3.  Grace Period: We will support the deprecated feature for at least one minor release cycle before removal.</p>"},{"location":"REPOSITORY_STRUCTURE/","title":"Repository Structure &amp; Open Core Architecture","text":"<p>This document explains the organization of the Paygod Kernel repository, highlighting the separation between the Public Core and the Extension Points that enable the Open Core model.</p>"},{"location":"REPOSITORY_STRUCTURE/#root-directory","title":"\ud83d\udcc2 Root Directory","text":"<pre><code>/\n\u251c\u2500\u2500 contracts/          # \ud83d\udcdc Canonical JSON Schemas (The Law)\n\u251c\u2500\u2500 docs/               # \ud83d\udcda Documentation &amp; Governance\n\u251c\u2500\u2500 packs/              # \ud83d\udce6 Policy Bundles (Starter Packs)\n\u251c\u2500\u2500 spec/               # \u2696\ufe0f Compliance Test Vectors (Golden Fixtures)\n\u251c\u2500\u2500 src/                # \ud83e\udde0 Core Kernel Source Code (.NET)\n\u251c\u2500\u2500 tools/              # \ud83d\udee0\ufe0f CLI &amp; Verification Scripts (Python)\n\u251c\u2500\u2500 LICENSE             # \u2696\ufe0f Apache 2.0 License\n\u251c\u2500\u2500 SECURITY.md         # \ud83d\udee1\ufe0f Security Policy &amp; Disclosure\n\u251c\u2500\u2500 TRADEMARK.md        # \u2122\ufe0f Trademark Usage Guidelines\n\u2514\u2500\u2500 CONTRIBUTING.md     # \ud83e\udd1d Contribution Guidelines\n</code></pre>"},{"location":"REPOSITORY_STRUCTURE/#key-components","title":"\ud83c\udfd7\ufe0f Key Components","text":""},{"location":"REPOSITORY_STRUCTURE/#1-spec-the-standard","title":"1. <code>spec/</code> (The Standard)","text":"<p>This is the \"Constitution\" of the system. It defines the mathematical truth that all implementations must adhere to. *   <code>test-vectors/</code>: JSON files containing \"Golden Fixtures\" for Canonicalization and Hashing. *   Role: Ensures that a Rust CLI, a .NET Server, and a Python Script all produce the exact same ledger hashes.</p>"},{"location":"REPOSITORY_STRUCTURE/#2-contracts-the-law","title":"2. <code>contracts/</code> (The Law)","text":"<p>Contains the versioned JSON Schemas that define valid data structures. *   <code>schemas/</code>: <code>observation.schema.json</code>, <code>decision.schema.json</code>, etc. *   Role: Enforces \"Strict Mode\" validation at the API boundary.</p>"},{"location":"REPOSITORY_STRUCTURE/#3-packs-the-value","title":"3. <code>packs/</code> (The Value)","text":"<p>Contains the \"Starter Packs\" that solve real business problems. *   <code>security/</code>: <code>secrets-in-repo-guard</code>, <code>critical-cve-blocker</code>. *   <code>compliance/</code>: <code>admin-drift-detection</code>. *   Role: Drives adoption by providing immediate value (\"Drop-in Security\").</p>"},{"location":"REPOSITORY_STRUCTURE/#4-src-the-engine","title":"4. <code>src/</code> (The Engine)","text":"<p>The core execution logic, designed as a set of decoupled services. *   <code>Paygod.Contracts</code>: Shared C# models generated from JSON Schemas. *   <code>Paygod.ControlEngine</code>: The stateless runtime that evaluates Policy Packs. *   <code>Paygod.Ledger.Service</code>: The immutable append-only log. *   Interfaces: <code>ILedgerStore</code>, <code>IPolicySource</code> (The Extension Points for Enterprise).</p>"},{"location":"REPOSITORY_STRUCTURE/#5-docs-the-strategy","title":"5. <code>docs/</code> (The Strategy)","text":"<ul> <li><code>OPEN_CORE_POLICY.md</code>: Defines the boundary between Community and Enterprise.</li> <li><code>PUBLIC_API_POLICY.md</code>: Defines the stable surface area (SemVer).</li> <li><code>adrs/</code>: Architectural Decision Records (Why we did what we did).</li> </ul>"},{"location":"REPOSITORY_STRUCTURE/#the-open-core-flow","title":"\ud83d\udd04 The Open Core Flow","text":"<ol> <li> <p>Community User:</p> <ul> <li>Downloads <code>paygod</code> CLI (built from <code>src/</code>).</li> <li>Uses <code>packs/security</code> to scan their repo.</li> <li>Stores results in a local <code>ledger.jsonl</code> file (Default <code>ILedgerStore</code>).</li> </ul> </li> <li> <p>Enterprise User:</p> <ul> <li>Uses the same <code>paygod</code> CLI.</li> <li>Configures it to use the <code>S3LedgerStore</code> (Proprietary Extension).</li> <li>Connects to <code>Paygod Cloud</code> for centralized dashboards.</li> </ul> </li> </ol>"},{"location":"REPOSITORY_STRUCTURE/#trust-verification","title":"\ud83d\udee1\ufe0f Trust &amp; Verification","text":"<ul> <li><code>tools/verify_spec.py</code>: Runs in CI to prove that the code complies with <code>spec/</code>.</li> <li><code>tools/dev/mock/test_pack.py (NOT source of truth)</code>: Runs in CI to prove that the Packs logic is correct.</li> </ul> <p>This structure ensures that Paygod Kernel is a complete, standalone open-source product, while leaving clear, architectural \"sockets\" for commercial features.</p>"},{"location":"SCHEMA_STABILITY/","title":"Schema Stability","text":""},{"location":"SCHEMA_STABILITY/#hash-source-of-truth-governance","title":"Hash Source of Truth (Governance)","text":"<p>Schema hashes in <code>contracts/schema-manifest.json</code> are governed by Git, not by local files. - CI computes hashes from Git blobs (HEAD) as the canonical source of truth. - Working tree bytes (CRLF/BOM/editor filters) MUST NOT redefine the legal hash. - Local tooling MAY provide preview using STAGED (index) then fallback to HEAD, but this is not the enforcement truth source.</p> <p>Schemas in <code>contracts/schemas/</code> are the project's public contracts.</p>"},{"location":"SCHEMA_STABILITY/#how-stability-is-enforced","title":"How stability is enforced","text":"<ul> <li><code>contracts/schema-manifest.json</code> stores SHA-256 digests for each schema file.</li> <li>CI checks that the manifest matches the current schemas.</li> </ul>"},{"location":"SCHEMA_STABILITY/#when-to-update-the-manifest","title":"When to update the manifest","text":"<p>Only when a schema change is intentional and compliant with: - <code>contracts/versioning/SCHEMA_SEMVER_POLICY.md</code></p> <p>Update:</p> <pre><code>python3 tools/update_schema_manifest.py\n</code></pre> <p>Validate:</p> <pre><code>python3 tools/check_schema_manifest.py\n</code></pre>"},{"location":"SECURITY_ROADMAP/","title":"Paygod Kernel Security Hardening Roadmap","text":"<p>This document outlines the strategic security enhancements required to elevate Paygod Kernel from a functional prototype to a production-grade, high-assurance financial system.</p>"},{"location":"SECURITY_ROADMAP/#1-container-hardening-priority-high","title":"1. Container Hardening (Priority: High)","text":"<p>Objective: Mitigate container breakout risks by enforcing least-privilege principles at the runtime level.</p>"},{"location":"SECURITY_ROADMAP/#implementation-strategy","title":"Implementation Strategy","text":"<ul> <li>Non-Root Execution: Modify all Dockerfiles to create and switch to a dedicated user (e.g., <code>app</code>) before the <code>ENTRYPOINT</code> instruction.</li> <li>Read-Only Filesystems: Configure <code>docker-compose.yml</code> and Kubernetes manifests to mount the root filesystem as read-only (<code>read_only: true</code>). Use explicit <code>tmpfs</code> mounts for temporary directories required by the runtime.</li> <li>Capability Dropping: Explicitly drop all Linux capabilities (<code>cap_drop: [ALL]</code>) and only add back strictly necessary ones (if any).</li> </ul>"},{"location":"SECURITY_ROADMAP/#2-supply-chain-security-priority-high","title":"2. Supply Chain Security (Priority: High)","text":"<p>Objective: Ensure the integrity of all software dependencies and build artifacts.</p>"},{"location":"SECURITY_ROADMAP/#implementation-strategy_1","title":"Implementation Strategy","text":"<ul> <li>Vulnerability Scanning: Integrate Trivy or Grype into the CI pipeline to scan base images and NuGet/Python packages for known CVEs before every build.</li> <li>SBOM Generation: Automatically generate a Software Bill of Materials (SBOM) for every release artifact to facilitate rapid impact analysis during security incidents.</li> <li>Dependency Pinning: Enforce strict version pinning (including hashes) for all dependencies in <code>csproj</code> and <code>requirements.txt</code> files.</li> </ul>"},{"location":"SECURITY_ROADMAP/#3-image-integrity-signing-priority-medium","title":"3. Image Integrity &amp; Signing (Priority: Medium)","text":"<p>Objective: Prevent the deployment of unauthorized or tampered container images.</p>"},{"location":"SECURITY_ROADMAP/#implementation-strategy_2","title":"Implementation Strategy","text":"<ul> <li>Cosign Integration: Use Sigstore Cosign to cryptographically sign container images immediately after the build phase in the CI pipeline.</li> <li>Admission Controllers: Deploy a Kubernetes Admission Controller (e.g., Kyverno or OPA Gatekeeper) to verify image signatures before allowing pods to start.</li> </ul>"},{"location":"SECURITY_ROADMAP/#4-cryptographic-ledger-locking-priority-critical","title":"4. Cryptographic Ledger Locking (Priority: Critical)","text":"<p>Objective: Protect the immutable ledger against retroactive tampering, even in the event of a key compromise.</p>"},{"location":"SECURITY_ROADMAP/#implementation-strategy_3","title":"Implementation Strategy","text":"<ul> <li>HSM Integration: Transition signing keys from software-based storage to Hardware Security Modules (HSM) or managed cloud KMS (Key Management Service).</li> <li>Key Rotation Policy: Implement automated key rotation for ledger signing keys.</li> <li>Checkpointing: Periodically publish the latest ledger root hash to a public, decentralized blockchain (e.g., Ethereum or Bitcoin) to serve as an indisputable timestamp proof.</li> </ul>"},{"location":"SECURITY_ROADMAP/#5-network-segmentation-priority-medium","title":"5. Network Segmentation (Priority: Medium)","text":"<p>Objective: Limit the blast radius of a potential breach by strictly controlling network traffic.</p>"},{"location":"SECURITY_ROADMAP/#implementation-strategy_4","title":"Implementation Strategy","text":"<ul> <li>Service Mesh: Implement mTLS (mutual TLS) between all microservices (Kernel, Ledger, Metrics) to ensure encrypted and authenticated communication.</li> <li>Network Policies: Apply strict Kubernetes Network Policies to deny all ingress/egress traffic by default, whitelisting only necessary communication paths.</li> </ul> <p>This roadmap is a living document. Security is a continuous process, not a final destination.</p>"},{"location":"SECURITY_ROADMAP/#pr-security-gate-github-actions-branch-protection","title":"PR Security Gate (GitHub Actions + Branch Protection)","text":"<p>Paygod Kernel treats security checks as merge-blocking on <code>main</code>.</p>"},{"location":"SECURITY_ROADMAP/#workflows","title":"Workflows","text":"<ul> <li><code>Paygod Kernel CI</code> \u2014 build, spec checks, schema stability, pack tests, and pack-provider separation lint.</li> <li><code>security-gate</code> \u2014 CodeQL, Dependency Review, secret scanning, and PR SBOM artifact.</li> </ul>"},{"location":"SECURITY_ROADMAP/#required-checks-branch-protection","title":"Required Checks (Branch Protection)","text":"<p>In GitHub: Settings \u2192 Branches \u2192 Branch protection rules \u2192 main, enable:</p> <ul> <li>Require status checks to pass before merging</li> <li>Select the checks below (names must match exactly):</li> </ul> <p>1) CodeQL (C#) 2) Dependency Review (PR) 3) Secret Scan (gitleaks) 4) SBOM (PR artifact) 5) build-and-test (from <code>Paygod Kernel CI</code>)</p> <p>Recommended toggles: - Require branches to be up to date before merging - Require signed commits (if your org enforces it) - Require approvals (CODEOWNERS-driven)</p>"},{"location":"SECURITY_ROADMAP/#notes","title":"Notes","text":"<ul> <li>Dependency Review runs only on pull requests by design.</li> <li>PR SBOM is uploaded as an artifact for transparency; release SBOM is still produced on tags.</li> <li>Container scanning is intentionally deferred until Docker images become a first-class MVP deliverable.</li> </ul>"},{"location":"SECURITY_ROADMAP/#making-the-security-gate-truly-merge-blocking-branch-protection","title":"Making the Security Gate truly merge-blocking (Branch Protection)","text":"<p>Workflows alone do not prevent merging. To make the Security Gate a real PR Gate, you must enable Branch Protection on <code>main</code> and set Required status checks to include the security jobs and CI build/test.</p>"},{"location":"SECURITY_ROADMAP/#required-checks-job-names-must-match-exactly","title":"Required checks (job names must match exactly)","text":"<ul> <li><code>CodeQL (C#)</code></li> <li><code>Dependency Review (PR)</code></li> <li><code>Secret Scan (gitleaks)</code></li> <li><code>SBOM (PR artifact)</code></li> <li><code>CI</code></li> </ul>"},{"location":"SECURITY_ROADMAP/#fast-path-recommended-apply-via-github-cli","title":"Fast path (recommended): apply via GitHub CLI","text":"<p>If you have repo admin rights, run:</p> <pre><code>gh auth login\nexport REPO=\"OWNER/REPO\"\nexport BRANCH=\"main\"\n./tools/admin/enable_branch_protection.sh\n</code></pre>"},{"location":"SECURITY_ROADMAP/#manual-path-ui","title":"Manual path (UI)","text":"<p>GitHub \u2192 Settings \u2192 Branches \u2192 Add rule for <code>main</code>: - \u2705 Require a pull request before merging - \u2705 Require status checks to pass before merging   - add the required checks listed above - \u2705 Require branches to be up to date before merging (recommended) - \u2705 Require Code Owner review (recommended)</p>"},{"location":"STARTER_PACKS/","title":"Paygod Starter Packs","text":"<p>Ready-to-use policy bundles to secure your infrastructure and ensure compliance from Day 1.</p>"},{"location":"STARTER_PACKS/#why-use-starter-packs","title":"\ud83d\ude80 Why use Starter Packs?","text":"<p>Instead of writing policies from scratch, start with our battle-tested packs. They address the most common and critical pain points in modern DevOps and Cloud environments.</p>"},{"location":"STARTER_PACKS/#available-packs","title":"\ud83d\udce6 Available Packs","text":""},{"location":"STARTER_PACKS/#1-security-guardrails","title":"1. Security Guardrails","text":"Pack Name Description Value secrets-in-repo-guard Pre-Commit / CIScans commits for high-entropy strings (API keys, tokens, passwords). Prevent Breaches: Stops credential leaks before they reach the repo.Save Money: Avoids expensive key rotation and incident response ($5k+ per leak). critical-cve-blocker CI / CDParses container scan reports (Trivy/Grype) and blocks artifacts with Critical CVEs. Supply Chain Security: Ensures no known exploits are shipped to production.Automated Gate: Removes manual review bottlenecks."},{"location":"STARTER_PACKS/#2-compliance-governance","title":"2. Compliance &amp; Governance","text":"Pack Name Description Value admin-drift-detection CloudTrail / IAMMonitors for <code>AdministratorAccess</code> grants without a linked Change Request (Ticket ID). Audit Readiness: Meets SOC2/ISO requirements for privileged access control.Zero Shadow IT: Prevents unauthorized admin escalation."},{"location":"STARTER_PACKS/#3-cost-control-finops-coming-soon","title":"3. Cost Control (FinOps) - Coming Soon","text":"Pack Name Description Value <code>idle-resource-reaper</code> CloudWatch / MetricsIdentifies and terminates EC2/RDS instances with &lt; 1% CPU usage for 7 days. Immediate Savings: Cut cloud waste by 20-30% automatically. <code>budget-forecast-alarm</code> Billing APIAlerts when forecasted spend exceeds budget by &gt; 10%. No Bill Shock: Catch run-away costs early."},{"location":"STARTER_PACKS/#how-to-install","title":"\ud83d\udee0\ufe0f How to Install","text":"<p>Packs are just directories! Clone the repo and point the Paygod CLI to the pack folder.</p> <pre><code># Validate a pack\npaygod validate --pack ./packs/core/critical-cve-blocker --input report.json\n</code></pre>"},{"location":"_attic/workflows_backup/","title":"Workflows Backup (Historical)","text":"<p>These workflow files are archived for historical reference only. They are NOT used by GitHub Actions.</p> <p>Active workflows live in: .github/workflows/.</p>"},{"location":"adr/ADR-0001-kernel-records/","title":"ADR 0001: Canonical Kernel Records &amp; Schema Validation","text":""},{"location":"adr/ADR-0001-kernel-records/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/ADR-0001-kernel-records/#context","title":"Context","text":"<p>Paygod Kernel requires a mechanism to validate data integrity across multiple boundaries (API ingress, internal messaging, ledger storage). The system must guarantee that invalid data is rejected before it can cause side effects or pollute the immutable ledger.</p> <p>Previously, validation was performed via ad-hoc logic in PowerShell scripts and C# classes. This led to: 1. Inconsistency: Validation rules in the API differed from those in the Ledger. 2. Shadow Validation: Rules existed in code but not in documentation. 3. Maintenance Burden: Every schema change required manual code updates in multiple places.</p>"},{"location":"adr/ADR-0001-kernel-records/#decision","title":"Decision","text":"<p>We will adopt JSON Schema (Draft 2020-12) as the single source of truth for all data contracts.</p> <p>The Canonical Record Types defined are: - <code>Observation</code>: Raw input data. - <code>MetricSpec</code>: Definition of how to measure data. - <code>Measurement</code>: The quantified result. - <code>Decision</code>: The final judgment. - <code>Evidence</code>: The bundle of inputs used. - <code>Impact</code>: The consequence/action to take. - <code>LedgerEntry</code>: The sealed record.</p> <p>Furthermore, we will enforce a Strict Validation Policy: 1. Formats are Assertions: All <code>format</code> keywords (e.g., <code>email</code>, <code>uuid</code>) must be validated strictly. 2. No Unknown Keywords: Schemas must not contain unrecognized keywords (to prevent typos). 3. Unified Engine: A single .NET-based CLI tool (<code>Paygod.SchemaValidator</code>) will be used across all environments (Local, CI, Production) to perform validation.</p>"},{"location":"adr/ADR-0001-kernel-records/#consequences","title":"Consequences","text":""},{"location":"adr/ADR-0001-kernel-records/#positive","title":"Positive","text":"<ul> <li>Guaranteed Consistency: The same validation logic runs everywhere.</li> <li>Contract-First Development: Developers must define the schema before writing code.</li> <li>Automated Documentation: API documentation can be auto-generated from the schemas.</li> <li>Reduced Liability: Strict format validation prevents common data integrity issues (e.g., invalid emails).</li> </ul>"},{"location":"adr/ADR-0001-kernel-records/#negative","title":"Negative","text":"<ul> <li>Initial Friction: Developers must learn JSON Schema syntax.</li> <li>Rigidity: \"Quick fixes\" to validation logic now require a formal schema update and release.</li> <li>Performance Overhead: Parsing and validating against full schemas is computationally more expensive than simple <code>if</code> checks (though mitigated by Native AOT compilation).</li> </ul>"},{"location":"adr/ADR-0001-kernel-records/#compliance","title":"Compliance","text":"<p>This decision supports Axiom 1: Schema Is Law.</p>"},{"location":"adr/ADR-0001-kernel-records/#references","title":"References","text":"<ul> <li>SCHEMA_SEMVER_POLICY.md</li> <li>PAYGOD_VALIDATOR_SPEC.md</li> </ul>"},{"location":"adr/ADR-0002-ledger-append-only/","title":"ADR 0002: Immutable Ledger Strategy","text":""},{"location":"adr/ADR-0002-ledger-append-only/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/ADR-0002-ledger-append-only/#context","title":"Context","text":"<p>Financial and regulatory systems (like Paygod) operate under strict audit requirements (OSCAL, SOC2). A traditional CRUD (Create, Read, Update, Delete) database model is insufficient because it allows history to be rewritten or deleted, destroying the audit trail.</p> <p>We need a storage strategy that guarantees: 1. Non-repudiation: Once an action is recorded, it cannot be denied. 2. Traceability: The full history of an entity is preserved. 3. Tamper-Evidence: Any attempt to alter past records is detectable.</p>"},{"location":"adr/ADR-0002-ledger-append-only/#decision","title":"Decision","text":"<p>We will implement an Append-Only Immutable Ledger as the authoritative data store for all decisions and assessments.</p>"},{"location":"adr/ADR-0002-ledger-append-only/#key-characteristics","title":"Key Characteristics:","text":"<ol> <li>No UPDATE/DELETE: The database user for the application will strictly lack <code>UPDATE</code> and <code>DELETE</code> permissions on ledger tables.</li> <li>Cryptographic Chaining: Each record will include a hash of the previous record (<code>PrevHash</code>), forming a Merkle-like chain.</li> <li>Corrections as Append: Modifications are modeled as new \"Correction\" records that reference the original record ID.</li> </ol>"},{"location":"adr/ADR-0002-ledger-append-only/#consequences","title":"Consequences","text":""},{"location":"adr/ADR-0002-ledger-append-only/#positive","title":"Positive","text":"<ul> <li>Audit-Ready: The system is compliant by design. Auditors can verify the integrity of the chain.</li> <li>Debuggability: We can reconstruct the exact state of the system at any point in time.</li> <li>Simpler Concurrency: Append-only writes reduce lock contention compared to complex updates.</li> </ul>"},{"location":"adr/ADR-0002-ledger-append-only/#negative","title":"Negative","text":"<ul> <li>Storage Growth: Database size will grow monotonically. Archival strategies will be needed for very old data.</li> <li>Query Complexity: Fetching the \"current state\" requires aggregating the history or maintaining a separate \"Read Model\" (CQRS).</li> <li>GDPR/Privacy: \"Right to be Forgotten\" is challenging; we must use \"Crypto-shredding\" (deleting the encryption key) or store PII off-ledger.</li> </ul>"},{"location":"adr/ADR-0002-ledger-append-only/#compliance","title":"Compliance","text":"<p>This decision supports Axiom 2: Ledger Immutability.</p>"},{"location":"adr/ADR-0002-ledger-append-only/#references","title":"References","text":"<ul> <li>NIST SP 800-53 (AU-9 Protection of Audit Information)</li> </ul>"},{"location":"adr/ADR-0003-metricspec-before-value/","title":"ADR-0003","text":"<p>Metric values must reference a MetricSpec.</p>"},{"location":"adr/ADR-0004-tech-stack/","title":"ADR 0004: Technology Stack Selection (.NET &amp; Python)","text":""},{"location":"adr/ADR-0004-tech-stack/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/ADR-0004-tech-stack/#context","title":"Context","text":"<p>Paygod Kernel requires high performance, strict typing, and enterprise-grade tooling for its core execution engine. However, the DAA (Decision Assessment Assistant) relies on advanced AI/ML capabilities where Python is the dominant ecosystem.</p> <p>We need to select a technology stack that leverages the strengths of both worlds without introducing excessive complexity.</p>"},{"location":"adr/ADR-0004-tech-stack/#decision","title":"Decision","text":"<p>We will adopt a Hybrid Polyglot Architecture:</p> <ol> <li>Core Kernel (.NET 8+):</li> <li>Role: API Gateway, Ledger Management, Validation, Execution.</li> <li> <p>Why: Strong typing, high performance (JIT/AOT), mature enterprise ecosystem, excellent support for microservices.</p> </li> <li> <p>DAA Engine (Python 3.11+):</p> </li> <li>Role: Data Science, LLM Integration, Complex Decision Logic.</li> <li> <p>Why: Unrivaled library support (Pandas, PyTorch, LangChain), standard for AI workloads.</p> </li> <li> <p>Communication:</p> </li> <li>Services communicate via gRPC (internal high-performance) or REST/JSON (external/public).</li> <li>Strict JSON Schema contracts define the interface between .NET and Python components.</li> </ol>"},{"location":"adr/ADR-0004-tech-stack/#consequences","title":"Consequences","text":""},{"location":"adr/ADR-0004-tech-stack/#positive","title":"Positive","text":"<ul> <li>Best Tool for Job: .NET provides safety and speed for the \"plumbing\"; Python provides flexibility and power for the \"brains\".</li> <li>Talent Pool: We can hire specialized .NET engineers for platform work and Data Scientists for decision logic.</li> <li>Scalability: Components can be scaled independently (e.g., scale DAA workers on GPU nodes, Kernel on CPU nodes).</li> </ul>"},{"location":"adr/ADR-0004-tech-stack/#negative","title":"Negative","text":"<ul> <li>Operational Complexity: Deployment pipeline must support two different runtimes.</li> <li>Context Switching: Developers working across the full stack must know two languages.</li> <li>Serialization Overhead: Data must be serialized/deserialized when crossing the language boundary.</li> </ul>"},{"location":"adr/ADR-0004-tech-stack/#compliance","title":"Compliance","text":"<p>This decision supports Axiom 3: Zero-Trust Execution (by enforcing strict contracts between components).</p>"},{"location":"adr/ADR-0004-tech-stack/#references","title":"References","text":"<ul> <li>PAYGOD_VALIDATOR_SPEC.md</li> </ul>"},{"location":"adrs/0005-unified-cli-validator/","title":"ADR 0005: Unified CLI Validator","text":""},{"location":"adrs/0005-unified-cli-validator/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/0005-unified-cli-validator/#context","title":"Context","text":"<p>Currently, Paygod Kernel relies on a mix of PowerShell scripts (<code>pwsh/</code>) and Python tools (<code>tools/</code>) for validation, testing, and automation. This fragmentation leads to: 1. Inconsistent Logic: Validation rules might differ slightly between languages. 2. Deployment Friction: Users need multiple runtimes (PowerShell Core, Python 3.x) installed. 3. Performance: Interpreted scripts are slower for high-volume validation in CI pipelines. 4. Developer Experience: Contributors have to learn multiple toolchains.</p>"},{"location":"adrs/0005-unified-cli-validator/#decision","title":"Decision","text":"<p>We will consolidate all client-side validation, testing, and interaction logic into a single, unified CLI binary.</p>"},{"location":"adrs/0005-unified-cli-validator/#technology-choice","title":"Technology Choice","text":"<ul> <li>Language: Rust or .NET (AOT compiled).</li> <li>Target: Single static binary (<code>paygod</code>) with no external dependencies.</li> <li>Scope:</li> <li><code>paygod validate</code>: Schema and policy validation.</li> <li><code>paygod test</code>: Run pack tests (replacing <code>test_pack.py</code>).</li> <li><code>paygod build</code>: Package policies into distribution artifacts.</li> </ul>"},{"location":"adrs/0005-unified-cli-validator/#consequences","title":"Consequences","text":""},{"location":"adrs/0005-unified-cli-validator/#positive","title":"Positive","text":"<ul> <li>Zero Dependency: Users just download one binary. No <code>pip install</code> or <code>Install-Module</code>.</li> <li>Speed: Native performance for JSON parsing and policy evaluation.</li> <li>Consistency: One codebase ensures validation logic is identical everywhere.</li> </ul>"},{"location":"adrs/0005-unified-cli-validator/#negative","title":"Negative","text":"<ul> <li>Migration Effort: Existing scripts need to be rewritten.</li> <li>Learning Curve: Contributors may need to learn Rust/.NET if they are only familiar with Python/PowerShell.</li> </ul>"},{"location":"adrs/0005-unified-cli-validator/#implementation-plan","title":"Implementation Plan","text":"<ol> <li>Define CLI specs in <code>docs/PAYGOD_VALIDATOR_SPEC.md</code> (Done).</li> <li>Build MVP validator replacing <code>test_pack.py</code>.</li> <li>Deprecate <code>pwsh/</code> and <code>tools/</code> in favor of the new CLI.</li> </ol>"},{"location":"adrs/0006-repository-separation-strategy/","title":"ADR 0006: Repository Separation Strategy (Open Core)","text":""},{"location":"adrs/0006-repository-separation-strategy/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/0006-repository-separation-strategy/#context","title":"Context","text":"<p>We are adopting an Open Core business model. This requires a technical architecture that allows us to develop a public, open-source \"Kernel\" while simultaneously building proprietary \"Enterprise\" extensions. We need a strategy to manage codebases, dependencies, and build pipelines without leaking commercial IP or crippling the open-source project.</p>"},{"location":"adrs/0006-repository-separation-strategy/#decision","title":"Decision","text":"<p>We will use a Multi-Repository Strategy with strict dependency direction.</p>"},{"location":"adrs/0006-repository-separation-strategy/#1-repository-structure","title":"1. Repository Structure","text":"<ul> <li><code>paygod/kernel</code> (Public): The source of truth for the core engine. Contains:<ul> <li>Core Logic (.NET/Rust)</li> <li>Public CLI (<code>paygod</code>)</li> <li>Public Schemas &amp; Contracts</li> <li>Community Packs</li> <li>Open Documentation</li> </ul> </li> <li><code>paygod/enterprise</code> (Private): The commercial product. Contains:<ul> <li>Management Dashboard (UI/Frontend)</li> <li>SaaS Infrastructure (IaC)</li> <li>Enterprise Connectors (AWS/Azure Integrations)</li> <li>Multi-tenant API Services</li> <li>Proprietary License Manager</li> </ul> </li> </ul>"},{"location":"adrs/0006-repository-separation-strategy/#2-dependency-flow","title":"2. Dependency Flow","text":"<p>Direction: <code>Enterprise</code> depends on <code>Kernel</code>. NEVER the reverse.</p> <ul> <li>The <code>Kernel</code> builds and publishes versioned artifacts (Nuget packages, Rust Crates, Docker Images).</li> <li>The <code>Enterprise</code> repo consumes these artifacts as standard dependencies.</li> <li>Extension Points: The Kernel exposes clean Interfaces/Traits (e.g., <code>ILedgerStore</code>, <code>IPolicySource</code>) that the Enterprise version implements to inject advanced capabilities (e.g., replacing a local file store with a centralized database).</li> </ul>"},{"location":"adrs/0006-repository-separation-strategy/#3-build-release","title":"3. Build &amp; Release","text":"<ul> <li>Kernel Release: Triggers a public GitHub Release + Package Registry upload.</li> <li>Enterprise Release: Triggers a private build that pulls the latest stable Kernel package, wraps it with proprietary modules, and deploys to the SaaS environment.</li> </ul>"},{"location":"adrs/0006-repository-separation-strategy/#consequences","title":"Consequences","text":""},{"location":"adrs/0006-repository-separation-strategy/#positive","title":"Positive","text":"<ul> <li>Security: Impossible to accidentally commit proprietary code to the public repo.</li> <li>Clarity: Clear separation of concerns. Open source contributors are not confused by \"stubbed\" or \"locked\" features.</li> <li>Licensing: Clean boundary. Apache 2.0 applies to everything in <code>kernel</code>. Commercial license applies to everything in <code>enterprise</code>.</li> </ul>"},{"location":"adrs/0006-repository-separation-strategy/#negative","title":"Negative","text":"<ul> <li>Complexity: Requires managing two CI/CD pipelines and synchronizing versions.</li> <li>Refactoring Friction: Changing a core interface in <code>kernel</code> requires a coordinated update in <code>enterprise</code>.</li> </ul>"},{"location":"adrs/0006-repository-separation-strategy/#compliance","title":"Compliance","text":"<p>To ensure this strategy works: 1.  No \"If Enterprise\" flags in Kernel: The Kernel code must not contain logic like <code>if (isEnterprise)</code>. Instead, it should use dependency injection or plugin interfaces. 2.  Public API First: Any feature needed by Enterprise must be exposed via a public API/Interface in the Kernel.</p>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/","title":"Design Specification: Paygod.SchemaValidator","text":""},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#1-overview","title":"1. Overview","text":"<p><code>Paygod.SchemaValidator</code> is a standalone .NET 8 CLI tool (and library) designed to serve as the Unified Validation Engine for the Paygod ecosystem. It enforces \"Schema is Law\" by strictly validating JSON data against JSON Schemas with strict format assertions.</p>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#2-core-objectives","title":"2. Core Objectives","text":"<ul> <li>Strictness: Enforce <code>format</code> keywords as assertions (e.g., email, date-time, uuid).</li> <li>Performance: Native AOT compilation for sub-second startup and execution.</li> <li>Portability: Single-file binary distribution for Linux (CI/Container) and Windows (Dev).</li> <li>Integration: Designed to be called by PowerShell scripts, GitHub Actions, and Docker containers.</li> </ul>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#3-architecture","title":"3. Architecture","text":""},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#31-technology-stack","title":"3.1 Technology Stack","text":"<ul> <li>Language: C# (.NET 8.0)</li> <li>Core Library: <code>JsonSchema.Net</code> (by Greg Dennis) - chosen for compliance with Draft 2020-12.</li> <li>CLI Framework: <code>System.CommandLine</code> or simple <code>args</code> parsing.</li> </ul>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#32-cli-interface","title":"3.2 CLI Interface","text":"<pre><code>paygod-validator validate --schema &lt;path_to_schema&gt; --instance &lt;path_to_data&gt; [--output-format &lt;text|json&gt;]\n</code></pre>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#arguments","title":"Arguments:","text":"<ul> <li><code>--schema, -s</code>: Path to the JSON Schema file (required).</li> <li><code>--instance, -i</code>: Path to the JSON data file to validate (required).</li> <li><code>--output-format, -o</code>: Output format. Defaults to <code>text</code> (human readable), <code>json</code> for machine parsing.</li> </ul>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#exit-codes","title":"Exit Codes:","text":"<ul> <li><code>0</code>: Validation Passed.</li> <li><code>1</code>: Validation Failed (Schema violations found).</li> <li><code>2</code>: Application Error (File not found, Invalid JSON syntax, etc.).</li> </ul>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#4-functional-requirements","title":"4. Functional Requirements","text":""},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#41-strict-format-validation","title":"4.1 Strict Format Validation","text":"<p>The tool MUST configure the underlying validation engine to treat formats as errors.</p> <pre><code>// Configuration Concept\nvar options = new ValidationOptions\n{\n    OutputFormat = OutputFormat.Detailed,\n    RequireFormatValidation = true // CRITICAL: This enables strict format checking\n};\n</code></pre>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#42-error-reporting","title":"4.2 Error Reporting","text":"<p>Output must be clear and actionable.</p> <p>Text Output Example:</p> <pre><code>[FAIL] Validation failed for 'user_profile.json'\nErrors:\n  - /contact/email: 'not-an-email' is not a valid email address.\n  - /meta/uuid: Value must match format 'uuid'.\n</code></pre> <p>JSON Output Example:</p> <pre><code>{\n  \"valid\": false,\n  \"errors\": [\n    {\n      \"path\": \"/contact/email\",\n      \"message\": \"'not-an-email' is not a valid email address\",\n      \"keyword\": \"format\"\n    }\n  ]\n}\n</code></pre>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#5-implementation-plan","title":"5. Implementation Plan","text":"<ol> <li>Scaffold Project: Create <code>src/Paygod.SchemaValidator</code> console app.</li> <li>Install Dependencies: Add <code>JsonSchema.Net</code>.</li> <li>Implement Logic:</li> <li>Load Schema &amp; Instance from file paths.</li> <li>Configure <code>ValidationOptions</code>.</li> <li>Execute <code>schema.Evaluate(instance, options)</code>.</li> <li>Parse results and render output.</li> <li>Build &amp; Publish: Configure <code>csproj</code> for <code>PublishAot=true</code>.</li> </ol>"},{"location":"design_specs/PAYGOD_VALIDATOR_SPEC/#6-future-extensions","title":"6. Future Extensions","text":"<ul> <li>Remote Schemas: Support fetching schemas from HTTP/S URLs.</li> <li>Batch Mode: Validate multiple files in one run for performance.</li> <li>Watch Mode: Re-run validation when files change (for dev experience).</li> </ul>"},{"location":"dev/architecture/","title":"Architecture","text":"<p>This page describes the architecture of the PayGod Kernel.</p>"},{"location":"dev/architecture/#core-components","title":"Core Components","text":"<p>The PayGod Kernel is composed of the following core components:</p> <ul> <li>Kernel: The core of the system, responsible for managing packs and processing transactions.</li> <li>Packs: Extensible modules that provide specific functionalities, such as payment methods or workflows.</li> <li>Contracts: Data contracts that define the structure of the data exchanged between the kernel and the packs.</li> </ul>"},{"location":"dev/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>The following diagram illustrates the high-level architecture of the PayGod Kernel:</p> <pre><code>graph TD\n    A[Client Application] --&gt; B(PayGod Kernel)\n    B --&gt; C{Packs}\n    C --&gt; D[Payment Gateway]\n    C --&gt; E[Ledger]\n</code></pre>"},{"location":"dev/contracts/","title":"Contracts","text":"<p>This page describes the data contracts used in the PayGod Kernel.</p>"},{"location":"dev/contracts/#introduction","title":"Introduction","text":"<p>Data contracts are used to define the structure of the data exchanged between the kernel and the packs. They are defined using JSON Schema.</p>"},{"location":"dev/contracts/#core-contracts","title":"Core Contracts","text":"<p>The following are the core data contracts used in the PayGod Kernel:</p> <ul> <li>Transaction: Represents a payment transaction.</li> <li>Ledger: Represents a ledger of transactions.</li> <li>Pack: Represents a pack that provides a specific functionality.</li> </ul> <p>For more details on the data contracts, please refer to the JSON Schema files in the <code>contracts/</code> directory of the repository.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>This guide will walk you through the process of setting up and using the PayGod Kernel.</p>"},{"location":"guide/getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have the following installed:</p> <ul> <li>.NET 8.0 SDK</li> <li>Git</li> </ul>"},{"location":"guide/getting-started/#installation","title":"Installation","text":"<ol> <li> <p>Clone the repository:</p> <p><code>bash git clone https://github.com/hamadalmunyif/paygod-kernel-mvp.git</code></p> </li> <li> <p>Navigate to the project directory:</p> <p><code>bash cd paygod-kernel-mvp</code></p> </li> <li> <p>Build the project:</p> <p><code>bash dotnet build</code></p> </li> </ol>"},{"location":"guide/getting-started/#usage","title":"Usage","text":"<p>To use the PayGod Kernel CLI, run the following command:</p> <pre><code>dotnet run --project src/PayGod.Cli -- [command]\n</code></pre> <p>For a list of available commands, run:</p> <pre><code>dotnet run --project src/PayGod.Cli -- --help\n</code></pre>"},{"location":"guide/introduction/","title":"Introduction","text":"<p>This page provides an introduction to the PayGod Kernel MVP project.</p>"},{"location":"guide/introduction/#what-is-paygod-kernel","title":"What is PayGod Kernel?","text":"<p>PayGod Kernel is a lightweight, extensible, and secure kernel for building payment applications. It provides a set of core functionalities that can be extended to support various payment methods and workflows.</p>"},{"location":"guide/introduction/#key-features","title":"Key Features","text":"<ul> <li>Extensible: The kernel is designed to be extensible, allowing developers to add new payment methods and workflows.</li> <li>Secure: The kernel is designed with security in mind, providing a secure environment for payment processing.</li> <li>Lightweight: The kernel is lightweight and has a small footprint, making it suitable for a wide range of applications.</li> </ul>"},{"location":"guide/introduction/#why-use-paygod-kernel","title":"Why use PayGod Kernel?","text":"<p>PayGod Kernel is a good choice for developers who want to build payment applications quickly and easily. It provides a solid foundation for building secure and reliable payment applications.</p>"}]}